========================================
RTP网络层仿真总结
========================================


文档概要
========================================

本文档主要是基于我对RTP网络层的理解撰写而成，涉及的内容主要是网络层实现上的的几个重要问题。




关于路由算法的总结
========================================

p99 来自传输层的路由（outbound）
-----------------------------------

#. 情形1，到传输层。

    * 单播是不可能的（因为会话层会进行短接）。多播，则由本站传送的广播包可能会定址为同一站的某个功能，此过程作为一种来自链路层的loop-back（回送，这个通常是指未经过更多处理或者改变而快速返回到源的一种方式，通常用于测试传输和通信）的结果。鉴于我们当前未考虑多播的情形，以及对于回送的理解，这个在目前版本中不可能出现。
    * 条件：(member AND (fundi (function_id) = this_station) 这个条件的意思是说:此站属于多播（广播）的地址范围内，并且final function位于本站内。

#. 情形2，到车辆总线。

    * 说明final function是位于同一个节点内（网段），无需进行节点的路由，也就是说目的功能位于同一个车辆总线上。则只需要对功能目录查表找到目的函数所在设备（站）的设备地址进行转发即可。
    * 条件：(final_node = AM_SAME_NODE) and  (next_station<> AM_SAME_STATION) and (next_station <> this_station) and (Link_Address of next_station = defined)。第一个条件是说final node位于同一个节点。二三条件说明，下一跳的站不是本站（或者节点），需要经过车辆总线。第四个条件说明下个站的链路地址是有定义的，而链路地址是通过查找站目录来获得（bus_id和device_address),所以此条件即是说下一站在站目录中有定义（入口）。
    * 从当前实现的角度来看，不会存在没有定义的站，所以上述的第四个条件应该是问题满足的（实际情形并非如此）

#. 情形3，到列车总线。

    * 说明，final function并不在此节点内（网段），而当前节点只是一个中间节点。那么当前节点会将这个包进行重新组装（链路头，网络头不用更改），发送到下一个节点。显然此种情形只可能发生在节点。
    * 条件：(next_station = AM_SAME_STATION) or ((next_station = this_station) and (final_node <> AM_SAME_NODE)) 标准中说明第一个条件用于标识通过列车总线来转发包（所以不能从字面来理解，这是一种规定），or后的条件说明： next_station = this_station是指站目录中的next_station等于当前的站，也就是说本站是可以到过final station所经过的站，而final_node <> AM_SAME_NODE很显然是指目的节点不在本节点，需要路由。
    * 构造相关的包进行转发即可。标准中说明，站目录可用来构造链路头（outbound)。如果站目录中的station_id和next_station相同，则说明可以目的站可以直接到达。

p100 来自车辆总线的路由(inbound)
-----------------------------------

#. 接上面的条件序列。情形4，到传输层

    * 从车辆总线到传输层.这说明本站即为目的站，而目的功能即在本站中，所以将包转发到上层传输层即可。
    * 条件：条件5，6以外的情形

#. 情形5，到另一条车辆总线。

    * 需要说明的是由于三型车一个站最多只连接有一条车辆总线，所以在实现中我们不去实现此种情形。
      发生此种情形的条件是，在同一个节点内，目的站不是本站（如果是则直接就转发到传输层了）
    * 条件：((final_node = AM_SAME_NODE) or (final_node = this_node)) and ((packet_topo = this_topo) or (packet_topo = AM_ANY_TOPO)) AND (( final_station <> this_station and final_station <> AM_SAME_NODE and final_station <> AM_UNKOWN))
    * 上述条件是说：首先必须处于同一个节点内，其次拓扑一致，最后就是要目的站不能是本站，也不能是本节点，也不能是未知

#. 情形6，到列车总线。

    * 这种情况是从车辆总线到列车总线的路由，发生条件是目的功能不在本节点内，而此节点只是作为中间的路由节点。
    * 条件：((final_node <> this_node and final_node <> AM_SAME_NODE and (packet_topo == this_topo or packet_topo = AM_ANY_TOPO)) or member
    * 上述条件中前两个是指不在同一节点内，三四条件说明要拓扑一致，最后一个or后的条件说明的是多播的情形（广播）

p101 来自列车总线的路由（这种情况与来自车辆总线的主要区别是对拓扑计数器的处理）：
-------------------------------------------------------------------------------------

#. 情形7，到传输层。

    * 说明目的功能在本节点和本站内。
    * 条件：((final_node = this_node) or(member)) and ((final_station = this_station) or (final_station = AM_SAME_STATION) or (final_station = AM_UNKOWN))
    * 上述条件的前两个是指功能在本节点内或者属于多播的地址范围，后面的条件是指目的站在本站
      至于最后一个或是指：目的站未知，也就是说无法进行下一步的路由，则认为在本站（但在我们的仿真过程中目的站不可能是未知的，所以这个或条件可以忽略，认为永远为假）

#. 情形8，到车辆总线。

    * 说明目的功能位于同一个节点内，而且目的站不是本站
    * 条件：(final_node = this_node or member) and (final_station<>this_station and final_station <> AM_SAME_STATION and final_station <> AM_UNKOWN)
    * 上述条件中的前两个是说同一个节点内或者满足多播的地址，后面的条件是说目的站不是本站，也不是未知。

#. 情形9，到列车总线。

    * 不可能发生





关于网络地址的编码
========================================

p95 车辆总线的网络地址编码
------------------------------

#. 情形1，在一个车辆总线内传输的包，并不承载拓扑计数器（拓扑的更改只在WTB可见），fgi和ogi为0，说明是单播

    * 此处情况的条件是在同一个车辆总线内传输，即final_node = AM_SAME_NODE = origin_node（说明不经过任何的路由至WTB的情况）

#. 情形2，由节点发送的包，承载的是拓扑计数器而不是final_node，很显然，因为当前node必为final_node，而下一站即为final_station。fgi为1

    * 条件是：origin_node <> AM_SAME_NODE 是说源节点与目的节点不相同，即跨网段传输

#. 情形3，发送给节点的包，此时承载的是拓扑计数器而不是origin_node，ogi为1说明
#. 情形4，从车辆总线的站以多播的形式向节点发送包或者相反，fgi和ogi都是1，说明是多播

p96 列车总线的网络地址编码，比较简单，参考标准中的说明。
------------------------------------------------------------



关于四种目录
========================================

由于group, node目录都是仅对于router station适用，而普通的terminal station是不具有的，另外站目录也指定的是站所对应的链路地址等信息，所以从实现的角度来看，这三种可以作为全局变量来实现，并且只在初运行时写入，后续只是只读的。

而一个站（节点）可能会有多个功能，而且这个数目也是不确定的，所以基于全局的功能目录不太合适，所以在实现的角度来看可以把功能目录作为任意的一个station进入状态机时初始化时写入，其后只是读。也就是在状态机的init状态的入口写入初始化代码。


关于Packet Pool
=====================

Packet Pool是用来控制共享内存大小的，即可申请和使用的包的总量是有限且固定的，
当使用的包（未归还）达到最大的包数时，则更多的申请将被拒绝。

目前实现的只是一种简单的流量控制, 而不牵扯到实现的内存分配等问题.

多播的实现
============

多播是与链路层中的多播和广播是相关的，即一个结点进行路由时, 
如果是多播,则向该节点上的所有MVB设备进行路由.


未实现的功能
=============

此处的未实现功能，也是当前阶段不会实现的功能。

#. 其它类型总线的参与通信（除MVB，WTB总线外）
#. 返回路径检测（指的是发送包的一方需要确认是否路径可达，replier会发送一个确认的帧）
#. 拓扑的变化（目前不考虑除初运行外的其它情况的拓扑变动）
#. 多播

接口的说明
=============

相关的接口在OPNET的具体实现中采用ICI通信的方式来实现.

与上层的接口(即需要传输层提供的信息):

#. 目的结点(final_node)
#. 源结点(origin_node)
#. 目的功能或者站(final_function_or_station)
#. 源功能或者站(origin_function_or_station)
#. 下一站(next_station)
#. 是否多播(fgi)
#. 系统地址或者用户地址(fsu)

与下层的接口(即向链路层提供的信息):

#. 下一站的设备地址(通过查station目录来获得)


OPNET仿真源码的ChangeLog
============================

============= ==============   ===================   ====================  ===============
时间            版本号          更新内容                更新人              其它
============= ==============   ===================   ====================  ===============
2009-07-07     0.2             增加了对packet pool
                               的实现,修改了init的
                               逻辑                       朱涛                

============= ==============   ===================   ====================  ===============


参考资料
========================================

#. IEC61375-2007-1





